三、实验心得体会

本次实验围绕两个典型漏洞——Struts2 的 OGNL 表达式注入漏洞（CVE-2020-17530）与 Jenkins 的远程代码执行漏洞（CVE-2018-1000861）展开，涵盖了漏洞原理理解、攻击复现、修复与效果验证的完整流程。在实验过程中，我不仅一定程度掌握了漏洞利用链的构造方式，也深刻体会到漏洞修复与验证的复杂性和系统性。

1. 多层次漏洞修复思维的形成

在 Struts2 的修复尝试中，我一开始尝试通过禁用 OGNL 表达式的方法来缓解漏洞，但由于配置文件路径误判与容器构建逻辑的忽视，导致修改未生效。这一过程让我意识到：

漏洞修复不仅仅是“改配置”，更重要的是“改对地方”、“改后生效”。

容器环境中修改文件后，若未重新构建镜像或创建新容器，变更往往无法落地。

单一的防护手段（如禁用 OGNL 静态方法）往往难以覆盖全部攻击面，更稳定有效的方式是直接升级框架版本。

最终选择升级 Struts2 到官方修复版本后，漏洞才被真正修复。这种对比让我更加明白，在生产环境中，官方更新和版本管理才是最稳妥的安全防线。

2. 攻防视角的切换带来的安全意识提升

在 Jenkins 漏洞的演示中，我从攻击者视角出发，尝试通过 Redis 渗透内部网络，再利用 Groovy 脚本接口执行远程命令，实现反弹 Shell。这个过程让我更加理解：

攻击者并非一定需要直接访问目标系统，通过旁路（如 Redis 可访问 Jenkins）即可发起有效攻击；

权限绕过+逻辑漏洞结合能形成高危利用链（如 Jenkins 脚本验证绕过 + Groovy 执行）；

攻击链的每一环都可能成为防御点，不应仅依赖最终接口的权限控制。

尤其在测试中，我尝试了无认证攻击、爆破账号密码后攻击等方式，这让我明白了安全防御不应局限于接口校验，更要在认证机制、网络隔离、接口限制、敏感功能禁用等方面全方位布防。

3. 工具使用与漏洞复现能力的提升

实验过程中，我熟练掌握了多个安全工具和操作方法：

docker exec / commit / ps / run 等容器操作指令，熟悉了在容器中定位配置文件与重构镜像的流程；

curl, gobuster, nmap 等工具辅助漏洞发现与测试，提升了漏洞验证的准确性；

mvn clean install 的使用让我理解了 Java 项目的构建机制，也更明白了为何修改源文件才有效；

使用 Wireshark 抓包、base64 编解码等基础手段辅助漏洞 payload 分析和理解，使攻击行为更加透明可控。


4. 安全意识的进一步加深

本次实验让我进一步认识到：安全从不是“一劳永逸”或“一招制敌”的过程，而是持续修复、测试、验证、加固的循环。一个小的失误（如修改了错误的配置路径、未重启容器）都有可能导致防护措施失效。

同时，攻击方式多样、路径复杂、工具灵活，安全防御者必须用整体性视角思考，从“代码、配置、架构、权限、边界”多个维度来完善系统。

5. 实验操作的简化

在实验中，我提出了2+1的操作模式，即两个容器加一张网卡，无论是对攻击方还是防守方，所有的操作都是得到上一层的访问控制权后将其作为跳板机来获取更内层的机器（容器）的访问控制权，所以实验操作中针对不同内网的渗透攻击和防护都可以只对本身和上一层网络中的机器进行操作，如果每个人都是在完整的靶场环境中实验的话对于深层的负责人会相对需要更多操作，而那些操作并不影响他们对应的实验内容，所以干脆只搭建2+1的部分靶场环境提高整体效率。对内层网络进行攻防的组员也都采用了这种方法，大大提高了我们实验效率，同时也不会影响实验结果。